<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>回溯算法交互动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #d4c5b9 0%, #c8b8a8 50%, #b8a898 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: rgba(248, 245, 242, 0.95);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            width: 95%;
            max-width: 1400px;
            min-height: 80vh;
            padding: 20px;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        .menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
        }

        .menu h1 {
            font-size: 2.5em;
            color: #8b7d6b;
            margin-bottom: 50px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.05);
        }

        .menu-buttons {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 40px;
            width: 100%;
            max-width: 900px;
        }

        .menu-btn {
            background: linear-gradient(135deg, #c8b8a8 0%, #b8a898 100%);
            color: #5c5448;
            border: none;
            padding: 60px 80px;
            font-size: 1.8em;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            flex: 1;
            min-width: 350px;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
        }

        .menu-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.2);
            background: linear-gradient(135deg, #b8a898 0%, #a89888 100%);
        }

        .algorithm-container {
            display: none;
            height: 100%;
        }

        .algorithm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #d4c5b9 0%, #c8b8a8 100%);
            border-radius: 10px;
            color: #5c5448;
        }

        .algorithm-title {
            font-size: 1.5em;
            font-weight: bold;
        }

        .back-btn {
            background: rgba(92, 84, 72, 0.2);
            color: #5c5448;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(92, 84, 72, 0.3);
        }

        .main-content {
            display: flex;
            gap: 20px;
            height: calc(100% - 80px);
        }

        .visualization-area {
            flex: 3;
            background: #f8f5f2;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .control-panel {
            flex: 1;
            background: #f8f5f2;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        .algorithm-info {
            flex: 1;
            background: #f8f5f2;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            margin-left: 20px;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #a89888;
            padding: 10px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .chess-cell {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 5px;
        }

        .chess-cell.white {
            background: #f0ead6;
        }

        .chess-cell.black {
            background: #d4c5b9;
        }

        .chess-cell.queen {
            background: #e6d7c3;
            box-shadow: 0 0 10px rgba(184, 168, 152, 0.5);
        }

        .chess-cell.attacked {
            background: #d4a574 !important;
            animation: pulse 0.5s ease-in-out;
        }

        .chess-cell.trying {
            background: #c8b8a8 !important;
            animation: glow 1s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px #c8b8a8;
            }

            to {
                box-shadow: 0 0 20px #c8b8a8;
            }
        }

        .graph-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        .graph-canvas {
            border: 2px solid #d4c5b9;
            border-radius: 10px;
            background: #f8f5f2;
            cursor: pointer;
        }

        .control-btn {
            background: linear-gradient(135deg, #c8b8a8 0%, #b8a898 100%);
            color: #5c5448;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            width: 100%;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, #b8a898 0%, #a89888 100%);
        }

        .control-btn:disabled {
            background: #e0d5ca;
            color: #a0958a;
            cursor: not-allowed;
            transform: none;
        }

        .status-panel {
            background: #f0ead6;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #c8b8a8;
        }

        .step-info {
            background: #f0ead6;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
            border-left: 3px solid #b8a898;
        }

        .step-info .step-info {
            background: #f8f5f2;
            margin: 8px 0;
            padding: 8px;
            border-left: 2px solid #d4c5b9;
            font-size: 0.85em;
        }

        .step-info h5 {
            color: #8b7d6b;
            margin: 0 0 5px 0;
            font-size: 1em;
            font-weight: bold;
        }

        .problem-description {
            font-size: 0.8em;
        }

        .speed-control {
            margin: 15px 0;
        }

        .speed-slider {
            width: 100%;
            margin: 10px 0;
        }

        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        .color-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }

        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .hidden {
            display: none !important;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .statistics {
            background: #f0ead6;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .statistics hr {
            margin: 8px 0;
            border: 1px solid #d4c5b9;
            border-top: 1px solid #d4c5b9;
            border-bottom: none;
            border-left: none;
            border-right: none;
        }

        .menu-description {
            color: #8b7d6b;
            margin-top: 40px;
            font-size: 1.1em;
        }

        .color-legend-red {
            background: #d4a574;
        }

        .color-legend-teal {
            background: #a4b5a0;
        }

        .color-legend-blue {
            background: #9bb5c7;
        }

        .color-legend-yellow {
            background: #d4c5a0;
        }

        .n-queens-selector {
            margin: 15px 0;
        }

        .board-size-input {
            width: 60px;
            padding: 5px;
            border: 2px solid #d4c5b9;
            border-radius: 5px;
            text-align: center;
            font-size: 1em;
            background: #f8f5f2;
            color: #5c5448;
        }

        .board-size-input:focus {
            outline: none;
            border-color: #c8b8a8;
        }

        .interaction-mode {
            margin: 15px 0;
        }

        .mode-buttons {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .mode-btn {
            background: #e0d5ca;
            color: #a0958a;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            flex: 1;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #c8b8a8 0%, #b8a898 100%);
            color: #5c5448;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .mode-btn:hover:not(.active) {
            background: #d4c5b9;
            color: #8b7d6b;
        }

        .chess-cell.manual-highlight {
            background: #e6d7c3 !important;
            box-shadow: 0 0 15px rgba(200, 184, 168, 0.8);
            animation: manualGlow 1s ease-in-out infinite alternate;
        }

        .chess-cell.invalid-position {
            background: #d4a574 !important;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes manualGlow {
            from {
                box-shadow: 0 0 10px rgba(200, 184, 168, 0.5);
            }

            to {
                box-shadow: 0 0 20px rgba(200, 184, 168, 0.9);
            }
        }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            25% {
                transform: translateX(-3px);
            }
            75% {
                transform: translateX(3px);
            }
        }

        .solution-indicator {
            background: #a4b5a0;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 0.9em;
            text-align: center;
        }

        .graph-complexity-selector {
            margin: 15px 0;
        }

        .complexity-select {
            width: 100%;
            padding: 5px;
            border: 2px solid #d4c5b9;
            border-radius: 5px;
            background: #f8f5f2;
            color: #5c5448;
            font-size: 1em;
            margin-top: 5px;
        }

        .complexity-select:focus {
            outline: none;
            border-color: #c8b8a8;
        }

        .manual-color-selector {
            margin: 15px 0;
        }

        .manual-color-selector.hidden {
            display: none;
        }

        .color-selector-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 40px;
            height: 40px;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .color-btn.active {
            border-color: #5c5448;
            box-shadow: 0 0 10px rgba(92, 84, 72, 0.5);
        }

        .color-btn-1 { background: #d4a574; }
        .color-btn-2 { background: #a4b5a0; }
        .color-btn-3 { background: #9bb5c7; }
        .color-btn-4 { background: #d4c5a0; }

        .graph-edge.conflict {
            stroke: #ff6b6b;
            stroke-width: 4;
            animation: conflictPulse 1s ease-in-out infinite;
        }

        .graph-node.trying {
            animation: nodeTrying 1s ease-in-out infinite alternate;
        }

        .graph-node.conflict {
            animation: nodeConflict 0.5s ease-in-out;
        }

        @keyframes conflictPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @keyframes nodeTrying {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        @keyframes nodeConflict {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(0.9); }
            75% { transform: scale(1.1); }
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .chess-cell {
                width: 35px;
                height: 35px;
                font-size: 1.5em;
            }

            .menu-buttons {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }

            .menu-btn {
                min-width: 280px;
                min-height: 120px;
                padding: 40px 50px;
                font-size: 1.4em;
            }

            .menu h1 {
                font-size: 2em;
                margin-bottom: 30px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- 主菜单 -->
        <div id="menu" class="menu">
            <h1>回溯算法可视化学习</h1>
            <div class="menu-buttons">
                <button class="menu-btn" onclick="showAlgorithm('queens')">
                    👑 N皇后问题
                </button>
                <button class="menu-btn" onclick="showAlgorithm('coloring')">
                    🎨 图着色问题
                </button>
            </div>
            <p class="menu-description">
                选择一个算法开始交互式学习体验
            </p>
        </div>

        <!-- 八皇后算法 -->
        <div id="queens-container" class="algorithm-container">
            <div class="algorithm-header">
                <div class="algorithm-title">N皇后问题 - 回溯算法可视化</div>
                <button class="back-btn" onclick="showMenu()">返回菜单</button>
            </div>
            <div class="main-content">
                <div class="visualization-area">
                    <div id="chess-board" class="chess-board"></div>
                    <div class="status-panel">
                        <div id="queens-status">准备开始：点击"开始求解"按钮</div>
                    </div>
                </div>
                <div class="control-panel">
                    <h3>控制面板</h3>
                    
                    <div class="n-queens-selector">
                        <label>棋盘大小：
                            <input type="number" id="board-size-input" class="board-size-input" min="4" max="12" value="8">
                            ×
                            <span id="board-size-display">8</span>
                        </label>
                    </div>

                    <button id="start-queens" class="control-btn">开始求解</button>
                    <button id="step-queens" class="control-btn" disabled>单步执行</button>
                    <button id="pause-queens" class="control-btn" disabled>暂停</button>
                    <button id="reset-queens" class="control-btn">重置</button>

                    <div class="speed-control">
                        <label>动画速度：<span id="speed-display">中等</span></label>
                        <input type="range" id="queens-speed" class="speed-slider" min="1" max="10" value="5">
                    </div>

                    <div class="interaction-mode">
                        <label>交互模式：</label>
                        <div class="mode-buttons">
                            <button id="auto-mode" class="mode-btn">自动求解</button>
                            <button id="manual-mode" class="mode-btn">手动放置</button>
                        </div>
                    </div>

                    <div class="statistics" id="queens-stats">
                        <div>棋盘大小: <span id="current-board-size">8</span></div>
                        <div>尝试次数: <span id="attempt-count">0</span></div>
                        <div>回溯次数: <span id="backtrack-count">0</span></div>
                        <div>当前行: <span id="current-row">0</span></div>
                        <div>执行时间: <span id="execution-time">0</span>ms</div>
                    </div>
                </div>
                <div class="algorithm-info">
                    <h3>算法详解</h3>
                    
                    <div class="step-info problem-description">
                        <h4>问题描述</h4>
                        <p>N皇后问题要求在N×N的棋盘上放置N个皇后，使得任意两个皇后都不能互相攻击。即任意两个皇后都不能处在同一行、同一列或同一斜线上。</p>
                    </div>

                    <div class="step-info">
                        <h4>算法思路</h4>
                        <div class="step-info">
                            <h5>1. 逐行放置策略</h5>
                            <p>从第一行开始，逐行尝试在每一行放置一个皇后，确保每行恰好有一个皇后。</p>
                        </div>
                        <div class="step-info">
                            <h5>2. 冲突检测机制</h5>
                            <p>对于每个位置，检查是否与已放置的皇后发生冲突：</p>
                            <p>• <strong>列冲突：</strong>检查同一列是否已有皇后</p>
                            <p>• <strong>对角线冲突：</strong>检查左上-右下和右上-左下对角线</p>
                        </div>
                        <div class="step-info">
                            <h5>3. 回溯搜索</h5>
                            <p>若当前行无法放置皇后，则回溯到上一行，移除该行的皇后并尝试下一个位置。</p>
                        </div>
                        <div class="step-info">
                            <h5>4. 搜索状态管理</h5>
                            <p>使用搜索栈保存每一步的状态，支持暂停、继续和单步执行功能。</p>
                        </div>
                    </div>

                    <div class="step-info">
                        <h4>复杂度分析</h4>
                        <div class="step-info">
                            <h5>时间复杂度</h5>
                            <p><strong>O(N!)：</strong>最坏情况下需要尝试N!种排列，但实际运行中由于剪枝效果会大大减少搜索空间。</p>
                        </div>
                        <div class="step-info">
                            <h5>空间复杂度</h5>
                            <p><strong>O(N)：</strong>需要存储皇后位置数组、搜索栈等辅助数据结构。</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 图着色算法 -->
        <div id="coloring-container" class="algorithm-container">
            <div class="algorithm-header">
                <div class="algorithm-title">图着色问题 - 回溯算法可视化</div>
                <button class="back-btn" onclick="showMenu()">返回菜单</button>
            </div>
            <div class="main-content">
                <div class="visualization-area">
                    <div class="graph-container">
                        <canvas id="graph-canvas" class="graph-canvas" width="400" height="300"></canvas>
                    </div>
                    <div class="color-legend">
                        <div class="color-item">
                            <div class="color-box color-legend-red"></div>
                            <span>红棕色</span>
                        </div>
                        <div class="color-item">
                            <div class="color-box color-legend-teal"></div>
                            <span>青绿色</span>
                        </div>
                        <div class="color-item">
                            <div class="color-box color-legend-blue"></div>
                            <span>蓝灰色</span>
                        </div>
                        <div class="color-item">
                            <div class="color-box color-legend-yellow"></div>
                            <span>米黄色</span>
                        </div>
                    </div>
                    <div class="status-panel">
                        <div id="coloring-status">准备开始：点击"开始着色"按钮</div>
                    </div>
                </div>
                <div class="control-panel">
                    <h3>控制面板</h3>
                    
                    <div class="graph-complexity-selector">
                        <label>图复杂度：</label>
                        <select id="graph-complexity" class="complexity-select">
                            <option value="simple">简单 (4节点)</option>
                            <option value="medium" selected>中等 (6节点)</option>
                            <option value="complex">复杂 (8节点)</option>
                        </select>
                    </div>

                    <button id="start-coloring" class="control-btn">开始着色</button>
                    <button id="step-coloring" class="control-btn" disabled>单步执行</button>
                    <button id="reset-coloring" class="control-btn">重置</button>
                    <button id="generate-graph" class="control-btn">生成新图</button>

                    <div class="speed-control">
                        <label>动画速度：<span id="coloring-speed-display">中等</span></label>
                        <input type="range" id="coloring-speed" class="speed-slider" min="1" max="10" value="5">
                    </div>

                    <div class="interaction-mode">
                        <label>交互模式：</label>
                        <div class="mode-buttons">
                            <button id="auto-coloring-mode" class="mode-btn">自动求解</button>
                            <button id="manual-coloring-mode" class="mode-btn">手动着色</button>
                        </div>
                    </div>

                    <div class="manual-color-selector hidden" id="manual-color-panel">
                        <label>选择颜色：</label>
                        <div class="color-selector-buttons">
                            <button class="color-btn color-btn-1 active" data-color="0">1</button>
                            <button class="color-btn color-btn-2" data-color="1">2</button>
                            <button class="color-btn color-btn-3" data-color="2">3</button>
                            <button class="color-btn color-btn-4" data-color="3">4</button>
                        </div>
                    </div>

                    <div class="statistics" id="coloring-stats">
                        <div>图复杂度: <span id="current-complexity">中等</span></div>
                        <div>节点数: <span id="node-count">6</span></div>
                        <div>边数: <span id="edge-count">8</span></div>
                        <div>尝试次数: <span id="coloring-attempt-count">0</span></div>
                        <div>回溯次数: <span id="coloring-backtrack-count">0</span></div>
                        <div>当前节点: <span id="current-node">-</span></div>
                        <div>当前颜色数: <span id="colors-used">0</span></div>
                        <hr>
                        <div>尝试颜色数: <span id="current-max-colors">1</span></div>
                        <div>最优颜色数: <span id="best-color-count">-</span></div>
                        <div>找到解决方案: <span id="solution-count">0</span></div>
                    </div>
                </div>
                <div class="algorithm-info">
                    <h3>算法详解</h3>
                    
                    <div class="step-info problem-description">
                        <h4>问题描述</h4>
                        <p>图着色问题要求给图的每个顶点分配颜色，使得相邻顶点颜色不同，并找到使用最少颜色数的着色方案。</p>
                    </div>

                    <div class="step-info">
                        <h4>算法思路</h4>
                        <div class="step-info">
                            <h5>1. 最优解搜索策略</h5>
                            <p>从1种颜色开始，逐步增加颜色数，直到找到第一个可行的着色方案，该方案即为最优解。</p>
                        </div>
                        <div class="step-info">
                            <h5>2. 回溯搜索机制</h5>
                            <p>在每个颜色数限制下，按节点顺序依次尝试着色：</p>
                            <p>• 对当前节点尝试所有可用颜色</p>
                            <p>• 检查与相邻节点是否产生冲突</p>
                            <p>• 若无冲突则继续下一节点，否则回溯</p>
                        </div>
                        <div class="step-info">
                            <h5>3. 冲突检测优化</h5>
                            <p>只需检查当前节点与其直接相邻节点的颜色冲突，时间复杂度为O(度数)。</p>
                        </div>
                        <div class="step-info">
                            <h5>4. 图结构生成</h5>
                            <p>随机生成多种专门设计的回溯图结构，包括完全图、轮图、星形图等，充分展示回溯过程。</p>
                        </div>
                    </div>

                    <div class="step-info">
                        <h4>复杂度分析</h4>
                        <div class="step-info">
                            <h5>时间复杂度</h5>
                            <p><strong>O(k^n)：</strong>其中n是节点数，k是颜色数。最坏情况下需要尝试每个节点的所有颜色组合。</p>
                        </div>
                        <div class="step-info">
                            <h5>空间复杂度</h5>
                            <p><strong>O(n)：</strong>存储图结构、颜色分配数组和递归调用栈。</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let currentAlgorithm = null;
        let isAnimating = false;
        let animationSpeed = 500;
        let isPaused = false;
        let stepMode = false;

        // 八皇后相关变量
        let boardSize = 8;
        let queensBoard = [];
        let queensSolution = [];
        let currentRow = 0;
        let attemptCount = 0;
        let backtrackCount = 0;
        let queensAnimationId = null;
        let startTime = 0;
        let isManualMode = false;
        let manualQueens = [];
        
        // 搜索状态保存变量（用于暂停恢复）
        let searchStack = [];  // 保存搜索栈状态
        let currentCol = 0;    // 当前正在尝试的列

        // 图着色相关变量
        let graph = {
            nodes: [],
            edges: [],
            adjacencyList: {}
        };
        let nodeColors = [];
        let coloringAttemptCount = 0;
        let coloringBacktrackCount = 0;
        let currentNodeIndex = 0;
        let coloringAnimationId = null;
        let availableColors = ['#d4a574', '#a4b5a0', '#9bb5c7', '#d4c5a0'];
        let isManualColoringMode = false;
        let manualColorIndex = 0;
        
        // 最优解相关变量
        let bestSolution = null;  // 最优着色方案
        let bestColorCount = Infinity;  // 最少颜色数
        let currentMaxColors = 1;  // 当前尝试的最大颜色数
        let solutionCount = 0;  // 找到的解决方案总数

        // 显示算法页面
        function showAlgorithm(algorithm) {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('queens-container').style.display = 'none';
            document.getElementById('coloring-container').style.display = 'none';

            if (algorithm === 'queens') {
                document.getElementById('queens-container').style.display = 'block';
                currentAlgorithm = 'queens';
                initQueens();
            } else if (algorithm === 'coloring') {
                document.getElementById('coloring-container').style.display = 'block';
                currentAlgorithm = 'coloring';
                initColoring();
            }
        }

        // 显示主菜单
        function showMenu() {
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('queens-container').style.display = 'none';
            document.getElementById('coloring-container').style.display = 'none';
            currentAlgorithm = null;

            // 清理动画
            if (queensAnimationId) clearTimeout(queensAnimationId);
            if (coloringAnimationId) clearTimeout(coloringAnimationId);
            isAnimating = false;
        }

        // 八皇后初始化
        function initQueens() {
            createChessBoard();
            resetQueensState();
            updateQueensStats();
            
            // 默认进入自动求解模式
            setInteractionMode(false);
            updateQueensStatus('自动模式：点击按钮开始算法求解');

            // 绑定控制按钮事件
            document.getElementById('start-queens').onclick = startQueens;
            document.getElementById('step-queens').onclick = stepQueens;
            document.getElementById('pause-queens').onclick = pauseQueens;
            document.getElementById('reset-queens').onclick = resetQueens;
            document.getElementById('manual-mode').onclick = () => setInteractionMode(true);
            document.getElementById('auto-mode').onclick = () => setInteractionMode(false);

            // 棋盘大小控制
            document.getElementById('board-size-input').oninput = function () {
                let size = parseInt(this.value);
                if (size < 4) {
                    size = 4;
                    this.value = 4;
                } else if (size > 12) {
                    size = 12;
                    this.value = 12;
                }
                
                boardSize = size;
                document.getElementById('board-size-display').textContent = boardSize;
                document.getElementById('current-board-size').textContent = boardSize;
                createChessBoard();
                resetQueensState();
                updateQueensStats();
            };

            // 速度控制
            document.getElementById('queens-speed').oninput = function () {
                const speed = parseInt(this.value);
                animationSpeed = 1100 - speed * 100;
                const labels = ['很慢', '慢', '较慢', '中慢', '中等', '中快', '较快', '快', '很快', '极快'];
                document.getElementById('speed-display').textContent = labels[speed - 1];
            };
        }

        // 创建棋盘
        function createChessBoard() {
            const board = document.getElementById('chess-board');
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;

            // 动态调整格子大小
            const cellSize = Math.min(50, Math.floor(400 / boardSize));
            
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    const cell = document.createElement('div');
                    cell.className = `chess-cell ${(i + j) % 2 === 0 ? 'white' : 'black'}`;
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';
                    cell.style.fontSize = Math.max(12, cellSize * 0.6) + 'px';
                    
                    // 添加点击事件用于手动模式
                    cell.addEventListener('click', () => handleCellClick(i, j));
                    cell.addEventListener('mouseenter', () => handleCellHover(i, j));
                    cell.addEventListener('mouseleave', () => handleCellLeave(i, j));
                    
                    board.appendChild(cell);
                }
            }
        }

        // 重置皇后状态
        function resetQueensState() {
            queensBoard = Array(boardSize).fill().map(() => Array(boardSize).fill(0));
            queensSolution = Array(boardSize).fill(-1);
            manualQueens = [];
            currentRow = 0;
            currentCol = 0;
            attemptCount = 0;
            backtrackCount = 0;
            searchStack = [];
            resetQueensBoard();
        }

        // 设置交互模式
        function setInteractionMode(manual) {
            isManualMode = manual;
            
            // 更新按钮样式
            document.getElementById('manual-mode').classList.toggle('active', manual === true);
            document.getElementById('auto-mode').classList.toggle('active', manual === false);
            
            // 更新按钮状态
            if (manual === true) {
                // 手动模式
                document.getElementById('start-queens').disabled = true;
                document.getElementById('step-queens').disabled = true;
                updateQueensStatus('手动模式：点击棋盘放置皇后');
            } else {
                // 自动模式
                document.getElementById('start-queens').disabled = false;
                document.getElementById('step-queens').disabled = false;
                updateQueensStatus('自动模式：点击按钮开始算法求解');
                clearManualHighlights();
            }
        }

        // 处理格子点击
        function handleCellClick(row, col) {
            if (isManualMode !== true || isAnimating) return;
            
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            if (cell.classList.contains('queen')) {
                // 移除皇后
                removeQueen(row, col);
                queensBoard[row][col] = 0;
                manualQueens = manualQueens.filter(q => !(q.row === row && q.col === col));
                updateQueensStatus(`移除皇后：第${row + 1}行第${col + 1}列`);
            } else {
                // 检查是否可以放置皇后
                if (isManualPositionSafe(row, col)) {
                    placeQueen(row, col);
                    queensBoard[row][col] = 1;
                    manualQueens.push({row, col});
                    updateQueensStatus(`放置皇后：第${row + 1}行第${col + 1}列`);
                    
                    // 检查是否完成
                    if (manualQueens.length === boardSize) {
                        updateQueensStatus('🎉 恭喜！您已成功手动解决N皇后问题！');
                        updateQueensStats();
                    }
                } else {
                    // 显示冲突
                    cell.classList.add('invalid-position');
                    setTimeout(() => {
                        cell.classList.remove('invalid-position');
                    }, 500);
                    updateQueensStatus(`冲突位置：第${row + 1}行第${col + 1}列不能放置皇后`);
                }
            }
        }

        // 处理格子悬停
        function handleCellHover(row, col) {
            if (isManualMode !== true || isAnimating) return;
            
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (!cell.classList.contains('queen') && isManualPositionSafe(row, col)) {
                cell.classList.add('manual-highlight');
            }
        }

        // 处理格子离开
        function handleCellLeave(row, col) {
            if (isManualMode !== true) return;
            
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.classList.remove('manual-highlight');
        }

        // 检查手动模式下位置是否安全
        function isManualPositionSafe(row, col) {
            for (let queen of manualQueens) {
                if (queen.row === row || queen.col === col ||
                    Math.abs(queen.row - row) === Math.abs(queen.col - col)) {
                    return false;
                }
            }
            return true;
        }

        // 清除手动模式高亮
        function clearManualHighlights() {
            document.querySelectorAll('.chess-cell').forEach(cell => {
                cell.classList.remove('manual-highlight', 'invalid-position');
            });
        }


        function startQueens() {
            if (isAnimating || isManualMode === true) return;

            isAnimating = true;
            stepMode = false;
            isPaused = false;
            startTime = Date.now();

            document.getElementById('start-queens').disabled = true;
            document.getElementById('step-queens').disabled = true;
            document.getElementById('pause-queens').disabled = false;
            document.getElementById('pause-queens').textContent = '暂停';

            // 只有在没有现有搜索状态时才重置
            if (searchStack.length === 0) {
                resetQueensBoard();
                resetQueensState();
            }
            
            updateQueensStatus('开始求解...');
            solveQueens();
        }

        // 单步执行八皇后
        function stepQueens() {
            if (isAnimating || isManualMode === true) return;

            stepMode = true;
            isAnimating = true;

            document.getElementById('start-queens').disabled = true;
            document.getElementById('step-queens').disabled = true;

            // 初始化搜索状态（如果是第一次单步执行）
            if (searchStack.length === 0 && currentRow === 0) {
                resetQueensBoard();
                resetQueensState();
                startTime = Date.now();
            }

            solveQueens();
        }

        // 暂停/继续八皇后
        function pauseQueens() {
            isPaused = !isPaused;
            document.getElementById('pause-queens').textContent = isPaused ? '继续' : '暂停';

            if (!isPaused && isAnimating) {
                // 从当前状态继续执行
                solveQueens();
            }
        }

        // 重置八皇后
        function resetQueens() {
            if (queensAnimationId) clearTimeout(queensAnimationId);

            isAnimating = false;
            stepMode = false;
            isPaused = false;

            // 保持当前交互模式不变
            const currentMode = isManualMode;
            
            document.getElementById('start-queens').disabled = (currentMode === true);
            document.getElementById('step-queens').disabled = (currentMode === true);
            document.getElementById('pause-queens').disabled = true;
            document.getElementById('pause-queens').textContent = '暂停';

            resetQueensState();
            updateQueensStats();
            
            if (currentMode === true) {
                updateQueensStatus('手动模式：点击棋盘放置皇后');
            } else {
                updateQueensStatus('自动模式：点击按钮开始算法求解');
            }
        }

        // 重置棋盘显示
        function resetQueensBoard() {
            const cells = document.querySelectorAll('.chess-cell');
            cells.forEach(cell => {
                cell.classList.remove('queen', 'attacked', 'trying', 'manual-highlight', 'invalid-position');
                cell.textContent = '';
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                cell.className = `chess-cell ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
            });

            queensBoard = Array(boardSize).fill().map(() => Array(boardSize).fill(0));
        }

        // 修复的八皇后求解算法（迭代版本，支持暂停恢复）
        async function solveQueens(startRow = 0) {
            // 初始化搜索状态
            if (startRow === 0 && searchStack.length === 0) {
                searchStack = [{row: 0, col: 0}];
                currentRow = 0;
                currentCol = 0;
            }

            while (searchStack.length > 0 && !isPaused) {
                const state = searchStack[searchStack.length - 1];
                currentRow = state.row;
                currentCol = state.col;
                
                updateQueensStats();

                // 检查是否找到解决方案
                if (currentRow === boardSize) {
                    updateQueensStats();
                    updateQueensStatus('🎉 找到解决方案！');
                    finishQueensAnimation();
                    return true;
                }

                let foundValidPosition = false;

                // 在当前行寻找可放置的位置
                for (let col = currentCol; col < boardSize && !isPaused; col++) {
                    attemptCount++;
                    updateQueensStats();

                    if (isSafe(currentRow, col)) {
                        // 找到安全位置，放置皇后
                        queensSolution[currentRow] = col;
                        queensBoard[currentRow][col] = 1;

                        if (!stepMode) {
                            highlightCell(currentRow, col, 'trying');
                            updateQueensStatus(`第${currentRow + 1}行：尝试在列${col + 1}放置皇后...`);
                            await new Promise(resolve => queensAnimationId = setTimeout(resolve, animationSpeed / 2));
                            if (isPaused) return false;
                        }

                        placeQueen(currentRow, col);
                        
                        if (stepMode) {
                            // 更新当前状态，准备下一步
                            searchStack[searchStack.length - 1] = {row: currentRow, col: col + 1};
                            searchStack.push({row: currentRow + 1, col: 0});
                            document.getElementById('step-queens').disabled = false;
                            isAnimating = false;
                            return false;
                        }

                        await new Promise(resolve => queensAnimationId = setTimeout(resolve, animationSpeed / 2));
                        if (isPaused) return false;

                        // 移动到下一行
                        searchStack[searchStack.length - 1] = {row: currentRow, col: col + 1};
                        searchStack.push({row: currentRow + 1, col: 0});
                        foundValidPosition = true;
                        break;
                    } else {
                        // 显示冲突
                        if (!stepMode && !isPaused) {
                            highlightAttacked(currentRow, col);
                            updateQueensStatus(`第${currentRow + 1}行：列${col + 1}位置冲突，尝试下一个位置`);
                            await new Promise(resolve => queensAnimationId = setTimeout(resolve, animationSpeed / 3));
                        }
                    }
                }

                // 如果在当前行没有找到有效位置，需要回溯
                if (!foundValidPosition && !isPaused) {
                    searchStack.pop(); // 移除当前行的状态
                    
                    if (searchStack.length === 0) {
                        updateQueensStatus('无解：该棋盘大小下无法解决N皇后问题');
                        finishQueensAnimation();
                        return false;
                    }

                    // 回溯到上一行
                    currentRow--;
                    backtrackCount++;
                    updateQueensStats();
                    
                    const prevCol = queensSolution[currentRow];
                    if (prevCol >= 0) {
                        updateQueensStatus(`第${currentRow + 1}行：回溯，移除列${prevCol + 1}的皇后`);
                        removeQueen(currentRow, prevCol);
                        queensBoard[currentRow][prevCol] = 0;
                        queensSolution[currentRow] = -1;

                        if (!stepMode) {
                            await new Promise(resolve => queensAnimationId = setTimeout(resolve, animationSpeed / 2));
                        }
                    }
                }
            }

            return false;
        }



        // 单步执行逻辑
        function solveQueensStep() {
            if (currentRow >= boardSize) {
                updateQueensStatus('🎉 找到解决方案！');
                finishQueensAnimation();
                return;
            }

            // 简化的单步逻辑
            let placed = false;
            for (let col = 0; col < boardSize; col++) {
                attemptCount++;
                updateQueensStats();
                
                if (isSafe(currentRow, col)) {
                    queensSolution[currentRow] = col;
                    queensBoard[currentRow][col] = 1;
                    placeQueen(currentRow, col);
                    updateQueensStatus(`第${currentRow + 1}行：在列${col + 1}放置皇后`);
                    currentRow++;
                    placed = true;
                    break;
                }
            }

            if (!placed && currentRow > 0) {
                // 需要回溯
                currentRow--;
                backtrackCount++;
                updateQueensStats();
                const col = queensSolution[currentRow];
                if (col >= 0) {
                    removeQueen(currentRow, col);
                    queensBoard[currentRow][col] = 0;
                    queensSolution[currentRow] = -1;
                }
                updateQueensStatus(`回溯到第${currentRow + 1}行`);
            } else if (!placed) {
                updateQueensStatus('无解：该棋盘大小下无法解决N皇后问题');
                finishQueensAnimation();
                return;
            }

            updateQueensStats();
            document.getElementById('step-queens').disabled = false;
            isAnimating = false;
        }

        // 检查位置是否安全
        function isSafe(row, col) {
            // 检查列
            for (let i = 0; i < row; i++) {
                if (queensBoard[i][col] === 1) return false;
            }

            // 检查左对角线
            for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
                if (queensBoard[i][j] === 1) return false;
            }

            // 检查右对角线
            for (let i = row - 1, j = col + 1; i >= 0 && j < boardSize; i--, j++) {
                if (queensBoard[i][j] === 1) return false;
            }

            return true;
        }

        // 高亮单元格
        function highlightCell(row, col, className) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.classList.add(className);
        }

        // 显示攻击路径
        function highlightAttacked(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.classList.add('attacked');

            setTimeout(() => {
                cell.classList.remove('attacked');
            }, animationSpeed / 2);
        }

        // 放置皇后
        function placeQueen(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.classList.remove('trying');
            cell.classList.add('queen');
            cell.textContent = '♕';
        }

        // 移除皇后
        function removeQueen(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.classList.remove('queen', 'trying');
            cell.textContent = '';
        }

        // 完成动画
        function finishQueensAnimation() {
            isAnimating = false;
            document.getElementById('start-queens').disabled = false;
            document.getElementById('step-queens').disabled = false;
            document.getElementById('pause-queens').disabled = true;
        }

        // 更新八皇后状态
        function updateQueensStatus(message) {
            document.getElementById('queens-status').textContent = message;
        }

        // 更新八皇后统计
        function updateQueensStats() {
            document.getElementById('current-board-size').textContent = boardSize;
            document.getElementById('attempt-count').textContent = attemptCount;
            document.getElementById('backtrack-count').textContent = backtrackCount;
            document.getElementById('current-row').textContent = currentRow + 1;
            
            // 更新执行时间
            if (startTime > 0) {
                const elapsed = Date.now() - startTime;
                document.getElementById('execution-time').textContent = elapsed;
            }
        }

        // 图着色初始化
        function initColoring() {
            generateRandomGraph();

            // 重置状态
            nodeColors = [];
            coloringAttemptCount = 0;
            coloringBacktrackCount = 0;
            currentNodeIndex = 0;
            manualColorIndex = 0; // 初始化手动颜色索引

            updateColoringStats();
            updateColoringStatus('准备开始：点击"开始着色"寻找最优方案');

            // 绑定控制按钮事件
            document.getElementById('start-coloring').onclick = startColoring;
            document.getElementById('step-coloring').onclick = stepColoring;
            document.getElementById('reset-coloring').onclick = resetColoring;
            document.getElementById('generate-graph').onclick = generateNewGraph;
            document.getElementById('manual-coloring-mode').onclick = () => setColoringInteractionMode(true);
            document.getElementById('auto-coloring-mode').onclick = () => setColoringInteractionMode(false);

            // 默认进入自动模式
            setColoringInteractionMode(false);

            // 速度控制
            document.getElementById('coloring-speed').oninput = function () {
                const speed = parseInt(this.value);
                animationSpeed = 1100 - speed * 100;
                const labels = ['很慢', '慢', '较慢', '中慢', '中等', '中快', '较快', '快', '很快', '极快'];
                document.getElementById('coloring-speed-display').textContent = labels[speed - 1];
            };

            // 图复杂度控制
            document.getElementById('graph-complexity').onchange = function () {
                generateRandomGraph();
                resetColoring();
            };
        }

        // 生成随机图（专门设计用于回溯演示）
        function generateRandomGraph() {
            const complexity = document.getElementById('graph-complexity')?.value || 'medium';
            let nodeCount;
            
            // 根据复杂度设置参数，重点是创建容易回溯的图
            switch(complexity) {
                case 'simple':
                    nodeCount = 4;
                    break;
                case 'medium':
                    nodeCount = 5;
                    break;
                case 'complex':
                    nodeCount = 6;
                    break;
                default:
                    nodeCount = 5;
            }

            // 初始化图结构
            graph.nodes = [];
            graph.edges = [];
            graph.adjacencyList = {};

            // 生成节点位置
            generateNodePositions(nodeCount);
            
            // 初始化邻接表
            for (let i = 0; i < nodeCount; i++) {
                graph.adjacencyList[i] = [];
            }

            // 生成专门设计的回溯图结构
            generateBacktrackingGraph(nodeCount);

            // 初始化节点颜色数组
            nodeColors = Array(nodeCount).fill(-1);

            drawGraph();
        }

        // 生成随机的回溯图结构（每次生成不同的图）
        function generateBacktrackingGraph(nodeCount) {
            // 随机选择一种图生成策略
            const strategies = getGraphStrategies(nodeCount);
            const strategy = strategies[Math.floor(Math.random() * strategies.length)];
            strategy();
        }

        // 获取不同复杂度下的图生成策略
        function getGraphStrategies(nodeCount) {
            const strategies = [];

            if (nodeCount === 4) {
                // 策略1：完全图（K4）- 需要4种颜色
                strategies.push(() => {
                    for (let i = 0; i < 4; i++) {
                        for (let j = i + 1; j < 4; j++) {
                            addEdge(i, j);
                        }
                    }
                });

                // 策略2：轮图（wheel graph）- 中心节点连接所有外围节点
                strategies.push(() => {
                    // 外围三角形
                    addEdge(0, 1);
                    addEdge(1, 2);
                    addEdge(2, 0);
                    // 中心节点3连接所有
                    addEdge(3, 0);
                    addEdge(3, 1);
                    addEdge(3, 2);
                });

                // 策略3：路径+额外边
                strategies.push(() => {
                    addEdge(0, 1);
                    addEdge(1, 2);
                    addEdge(2, 3);
                    addEdge(0, 3); // 形成环
                    if (Math.random() > 0.5) addEdge(0, 2); // 随机添加对角线
                });

            } else if (nodeCount === 5) {
                // 策略1：五角星形
                strategies.push(() => {
                    for (let i = 0; i < 5; i++) {
                        addEdge(i, (i + 2) % 5); // 每个节点连接距离为2的节点
                    }
                });

                // 策略2：轮图（中心+外围）
                strategies.push(() => {
                    // 外围四边形
                    for (let i = 0; i < 4; i++) {
                        addEdge(i, (i + 1) % 4);
                    }
                    // 中心节点连接所有外围
                    for (let i = 0; i < 4; i++) {
                        addEdge(4, i);
                    }
                });

                // 策略3：两个三角形共享一个节点
                strategies.push(() => {
                    // 第一个三角形：0,1,2
                    addEdge(0, 1);
                    addEdge(1, 2);
                    addEdge(2, 0);
                    
                    // 第二个三角形：2,3,4 (共享节点2)
                    addEdge(2, 3);
                    addEdge(3, 4);
                    addEdge(4, 2);
                    
                    // 随机添加额外连接
                    if (Math.random() > 0.3) addEdge(0, 3);
                    if (Math.random() > 0.3) addEdge(1, 4);
                });

                // 策略4：Petersen图的子图
                strategies.push(() => {
                    addEdge(0, 1);
                    addEdge(1, 2);
                    addEdge(2, 3);
                    addEdge(3, 4);
                    addEdge(4, 0); // 外围环
                    addEdge(0, 2); // 跳跃连接
                    addEdge(1, 4);
                });

            } else if (nodeCount === 6) {
                // 策略1：两个完全连接的三角形
                strategies.push(() => {
                    // 第一个三角形
                    addEdge(0, 1);
                    addEdge(1, 2);
                    addEdge(2, 0);
                    
                    // 第二个三角形
                    addEdge(3, 4);
                    addEdge(4, 5);
                    addEdge(5, 3);
                    
                    // 随机连接两个三角形
                    const connections = [
                        [0, 3], [0, 4], [0, 5],
                        [1, 3], [1, 4], [1, 5],
                        [2, 3], [2, 4], [2, 5]
                    ];
                    const numConnections = 2 + Math.floor(Math.random() * 4); // 2-5个连接
                    for (let i = 0; i < numConnections; i++) {
                        const connection = connections[Math.floor(Math.random() * connections.length)];
                        addEdge(connection[0], connection[1]);
                        connections.splice(connections.indexOf(connection), 1);
                    }
                });

                // 策略2：轮图变体
                strategies.push(() => {
                    // 外围五边形
                    for (let i = 0; i < 5; i++) {
                        addEdge(i, (i + 1) % 5);
                    }
                    // 中心节点
                    for (let i = 0; i < 5; i++) {
                        if (Math.random() > 0.2) { // 不是所有外围节点都连接中心
                            addEdge(5, i);
                        }
                    }
                    // 确保至少有3个连接到中心
                    let centerConnections = 0;
                    for (let i = 0; i < 5; i++) {
                        if (graph.adjacencyList[5].includes(i)) centerConnections++;
                    }
                    while (centerConnections < 3) {
                        const randomNode = Math.floor(Math.random() * 5);
                        if (!graph.adjacencyList[5].includes(randomNode)) {
                            addEdge(5, randomNode);
                            centerConnections++;
                        }
                    }
                });

                // 策略3：双层结构
                strategies.push(() => {
                    // 下层三角形：0,1,2
                    addEdge(0, 1);
                    addEdge(1, 2);
                    addEdge(2, 0);
                    
                    // 上层三角形：3,4,5
                    addEdge(3, 4);
                    addEdge(4, 5);
                    addEdge(5, 3);
                    
                    // 垂直连接（每个上层节点连接1-2个下层节点）
                    for (let upper = 3; upper <= 5; upper++) {
                        const connections = Math.floor(Math.random() * 2) + 1; // 1或2个连接
                        const availableLower = [0, 1, 2];
                        for (let c = 0; c < connections && availableLower.length > 0; c++) {
                            const lowerIndex = Math.floor(Math.random() * availableLower.length);
                            const lower = availableLower[lowerIndex];
                            addEdge(upper, lower);
                            availableLower.splice(lowerIndex, 1);
                        }
                    }
                });

                // 策略4：接近完全图的随机子图
                strategies.push(() => {
                    const allPossibleEdges = [];
                    for (let i = 0; i < 6; i++) {
                        for (let j = i + 1; j < 6; j++) {
                            allPossibleEdges.push([i, j]);
                        }
                    }
                    
                    // 随机选择60%-85%的边
                    const edgeCount = Math.floor(allPossibleEdges.length * (0.6 + Math.random() * 0.25));
                    for (let i = 0; i < edgeCount; i++) {
                        const edgeIndex = Math.floor(Math.random() * allPossibleEdges.length);
                        const edge = allPossibleEdges[edgeIndex];
                        addEdge(edge[0], edge[1]);
                        allPossibleEdges.splice(edgeIndex, 1);
                    }
                });
            }

            return strategies;
        }

        // 生成节点位置
        function generateNodePositions(nodeCount) {
            const centerX = 200;
            const centerY = 150;
            const minRadius = 80;
            const maxRadius = 120;

            if (nodeCount <= 6) {
                // 随机选择布局方式
                const layoutType = Math.random();
                
                if (layoutType < 0.6) {
                    // 圆形布局（60%概率）
                    const baseAngle = Math.random() * 2 * Math.PI; // 随机起始角度
                    for (let i = 0; i < nodeCount; i++) {
                        const angle = baseAngle + (i / nodeCount) * 2 * Math.PI + (Math.random() * 0.4 - 0.2);
                        const radius = minRadius + Math.random() * (maxRadius - minRadius);
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        graph.nodes.push({ id: i, x: x, y: y });
                    }
                } else if (layoutType < 0.8) {
                    // 椭圆布局（20%概率）
                    const radiusX = minRadius + Math.random() * 40;
                    const radiusY = minRadius * 0.6 + Math.random() * 30;
                    const baseAngle = Math.random() * 2 * Math.PI;
                    for (let i = 0; i < nodeCount; i++) {
                        const angle = baseAngle + (i / nodeCount) * 2 * Math.PI + (Math.random() * 0.3 - 0.15);
                        const x = centerX + radiusX * Math.cos(angle);
                        const y = centerY + radiusY * Math.sin(angle);
                        graph.nodes.push({ id: i, x: x, y: y });
                    }
                } else {
                    // 随机散布布局（20%概率）
                    for (let i = 0; i < nodeCount; i++) {
                        const x = 50 + Math.random() * 300;
                        const y = 50 + Math.random() * 200;
                        graph.nodes.push({ id: i, x: x, y: y });
                    }
                }
            } else {
                // 网格布局加随机偏移
                const cols = Math.ceil(Math.sqrt(nodeCount));
                const rows = Math.ceil(nodeCount / cols);
                const cellWidth = 300 / cols;
                const cellHeight = 200 / rows;
                
                for (let i = 0; i < nodeCount; i++) {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const x = 50 + col * cellWidth + (Math.random() - 0.5) * 30;
                    const y = 50 + row * cellHeight + (Math.random() - 0.5) * 30;
                    graph.nodes.push({ id: i, x: x, y: y });
                }
            }
        }

        // 生成随机边
        function generateRandomEdges(nodeCount, targetEdgeCount) {
            const maxPossibleEdges = nodeCount * (nodeCount - 1) / 2;
            targetEdgeCount = Math.min(targetEdgeCount, maxPossibleEdges);
            
            // 首先确保图连通 - 生成生成树
            const visited = new Set();
            const unvisited = new Set();
            for (let i = 1; i < nodeCount; i++) {
                unvisited.add(i);
            }
            visited.add(0);
            
            while (unvisited.size > 0) {
                const visitedNode = Array.from(visited)[Math.floor(Math.random() * visited.size)];
                const unvisitedNode = Array.from(unvisited)[Math.floor(Math.random() * unvisited.size)];
                
                addEdge(visitedNode, unvisitedNode);
                visited.add(unvisitedNode);
                unvisited.delete(unvisitedNode);
            }
            
            // 添加更多边以达到目标边数
            let attempts = 0;
            while (graph.edges.length < targetEdgeCount && attempts < targetEdgeCount * 3) {
                const from = Math.floor(Math.random() * nodeCount);
                const to = Math.floor(Math.random() * nodeCount);
                
                if (from !== to && !graph.adjacencyList[from].includes(to)) {
                    addEdge(from, to);
                }
                attempts++;
            }
        }

        // 添加边的辅助函数
        function addEdge(from, to) {
            graph.edges.push({ from, to });
            graph.adjacencyList[from].push(to);
            graph.adjacencyList[to].push(from);
        }

        // Canvas相关变量
        let canvas, ctx;
        let nodeRadius = 25;
        let hoveredNode = -1;
        let selectedNode = -1;

        // 绘制图（Canvas版本）
        function drawGraph() {
            canvas = document.getElementById('graph-canvas');
            ctx = canvas.getContext('2d');
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制边
            graph.edges.forEach((edge, index) => {
                const fromNode = graph.nodes[edge.from];
                const toNode = graph.nodes[edge.to];
                
                drawEdge(fromNode, toNode, index);
            });

            // 绘制节点
            graph.nodes.forEach((node, index) => {
                drawNode(node, index);
            });
            
            // 绑定Canvas点击事件
            if (!canvas.hasEventListener) {
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('mouseleave', handleCanvasMouseLeave);
                canvas.hasEventListener = true;
            }
        }

        // 绘制边
        function drawEdge(fromNode, toNode, edgeIndex) {
            ctx.save();
            
            // 检查是否是冲突边
            const isConflict = isEdgeConflict(edgeIndex);
            
            ctx.strokeStyle = isConflict ? '#ff6b6b' : '#8b7d6b';
            ctx.lineWidth = isConflict ? 4 : 2;
            ctx.globalAlpha = isConflict ? 0.8 : 1;
            
            ctx.beginPath();
            ctx.moveTo(fromNode.x, fromNode.y);
            ctx.lineTo(toNode.x, toNode.y);
            ctx.stroke();
            
            ctx.restore();
        }

        // 绘制节点
        function drawNode(node, nodeIndex) {
            ctx.save();
            
            // 获取节点状态
            const isHovered = hoveredNode === nodeIndex;
            const isTrying = selectedNode === nodeIndex;
            const nodeColor = nodeColors[nodeIndex];
            
            // 绘制节点圆圈
            ctx.beginPath();
            ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);
            
            // 设置填充颜色
            if (nodeColor !== undefined && nodeColor !== -1) {
                ctx.fillStyle = availableColors[nodeColor];
            } else {
                ctx.fillStyle = '#f8f5f2';
            }
            
            ctx.fill();
            
            // 设置边框
            ctx.strokeStyle = isHovered ? '#5c5448' : '#8b7d6b';
            ctx.lineWidth = isHovered ? 3 : 2;
            ctx.stroke();
            
            // 动画效果（模拟CSS动画）
            if (isTrying) {
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeRadius + 3, 0, 2 * Math.PI);
                ctx.strokeStyle = '#5c5448';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // 绘制节点标签
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(nodeIndex.toString(), node.x, node.y);
            
            ctx.restore();
        }

        // Canvas鼠标事件处理
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const clickedNode = getNodeAtPosition(x, y);
            if (clickedNode !== -1) {
                handleNodeClick(clickedNode);
            }
        }

        function handleCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const newHoveredNode = getNodeAtPosition(x, y);
            
            if (newHoveredNode !== hoveredNode) {
                if (hoveredNode !== -1) {
                    handleNodeLeave(hoveredNode);
                }
                hoveredNode = newHoveredNode;
                if (hoveredNode !== -1) {
                    handleNodeHover(hoveredNode);
                }
                drawGraph(); // 重新绘制以显示悬停效果
            }
        }

        function handleCanvasMouseLeave() {
            if (hoveredNode !== -1) {
                handleNodeLeave(hoveredNode);
                hoveredNode = -1;
                drawGraph();
            }
        }

        // 获取位置处的节点
        function getNodeAtPosition(x, y) {
            for (let i = 0; i < graph.nodes.length; i++) {
                const node = graph.nodes[i];
                const distance = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                if (distance <= nodeRadius) {
                    return i;
                }
            }
            return -1;
        }

        // 检查边是否冲突
        function isEdgeConflict(edgeIndex) {
            const edge = graph.edges[edgeIndex];
            const fromColor = nodeColors[edge.from];
            const toColor = nodeColors[edge.to];
            
            return fromColor !== undefined && fromColor !== -1 && 
                   toColor !== undefined && toColor !== -1 && 
                   fromColor === toColor;
        }

        // 设置图着色交互模式
        function setColoringInteractionMode(manual) {
            isManualColoringMode = manual;
            
            // 更新按钮样式
            document.getElementById('manual-coloring-mode').classList.toggle('active', manual === true);
            document.getElementById('auto-coloring-mode').classList.toggle('active', manual === false);
            
            // 显示/隐藏颜色选择器
            const colorPanel = document.getElementById('manual-color-panel');
            if (manual === true) {
                colorPanel.classList.remove('hidden');
                // 绑定颜色按钮事件
                setupColorButtons();
            } else {
                colorPanel.classList.add('hidden');
            }
            
            // 更新按钮状态
            if (manual === true) {
                // 手动模式
                document.getElementById('start-coloring').disabled = true;
                document.getElementById('step-coloring').disabled = true;
                updateColoringStatus('手动模式：选择颜色后点击节点进行着色');
            } else {
                // 自动模式
                document.getElementById('start-coloring').disabled = false;
                document.getElementById('step-coloring').disabled = false;
                updateColoringStatus('自动模式：点击按钮寻找最优着色方案');
            }
        }

        // 设置颜色按钮事件
        function setupColorButtons() {
            document.querySelectorAll('.color-btn').forEach((btn, index) => {
                btn.onclick = () => {
                    // 更新活动状态
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    manualColorIndex = parseInt(btn.dataset.color);
                    updateColoringStatus(`选择颜色${manualColorIndex + 1}：点击节点进行着色`);
                };
            });
        }

        // 开始图着色（寻找最优解）
        function startColoring() {
            if (isAnimating) return;

            isAnimating = true;
            stepMode = false;

            document.getElementById('start-coloring').disabled = true;
            document.getElementById('step-coloring').disabled = true;

            resetColoring();
            
            // 重置最优解搜索状态
            bestSolution = null;
            bestColorCount = Infinity;
            solutionCount = 0;
            
            updateColoringStatus('开始寻找最优着色方案...');
            
            // 从1种颜色开始尝试，逐步增加
            currentMaxColors = 1;
            setTimeout(() => {
                findOptimalColoring();
            }, 500);
        }

        // 单步执行图着色
        function stepColoring() {
            if (isAnimating) return;

            stepMode = true;
            isAnimating = true;

            document.getElementById('start-coloring').disabled = true;
            document.getElementById('step-coloring').disabled = true;

            if (currentNodeIndex === 0 && nodeColors.every(c => c === -1)) {
                resetColoring();
                // 初始化最优解搜索
                bestSolution = null;
                bestColorCount = Infinity;
                solutionCount = 0;
                currentMaxColors = 1;
            }

            // 单步模式下尝试当前颜色数限制下的着色
            solveColoringWithLimit(currentNodeIndex, currentMaxColors);
        }

        // 递归回溯算法（专门用于展示回溯）
        // 寻找最优着色方案（使用最少颜色数）
        async function findOptimalColoring() {
            updateColoringStatus(`尝试使用${currentMaxColors}种颜色进行着色...`);
            updateColoringStats();
            
            // 重置当前搜索状态
            nodeColors = Array(graph.nodes.length).fill(-1);
            currentNodeIndex = 0;
            
            // 尝试用当前颜色数着色
            const success = await solveColoringWithLimit(0, currentMaxColors);
            
            if (success) {
                // 找到解决方案
                bestSolution = [...nodeColors];
                bestColorCount = currentMaxColors;
                solutionCount++;
                
                updateColoringStatus(`🎉 找到最优解！使用${bestColorCount}种颜色完成着色`);
                
                // 显示最优解
                nodeColors = [...bestSolution];
                drawGraph();
                finishColoringAnimation();
                return;
            } else {
                // 当前颜色数无法着色，增加颜色数继续尝试
                currentMaxColors++;
                
                if (currentMaxColors > availableColors.length) {
                    updateColoringStatus('❌ 超出可用颜色数量，无法完成着色');
                    finishColoringAnimation();
                    return;
                }
                
                // 延迟后继续尝试下一个颜色数
                setTimeout(() => {
                    findOptimalColoring();
                }, animationSpeed);
            }
        }

        // 在颜色数限制下尝试着色
        async function solveColoringWithLimit(nodeIndex, maxColors) {
            if (nodeIndex >= graph.nodes.length) {
                // 成功着色所有节点
                return true;
            }

            currentNodeIndex = nodeIndex;
            updateColoringStats();

            // 尝试每种可用颜色（限制在maxColors范围内）
            for (let colorIndex = 0; colorIndex < maxColors; colorIndex++) {
                coloringAttemptCount++;
                updateColoringStats();

                // 显示正在尝试的颜色
                selectedNode = nodeIndex;
                updateColoringStatus(`节点${nodeIndex}：尝试颜色${colorIndex + 1}/${maxColors}...`);
                drawGraph();
                
                if (stepMode) {
                    // 单步模式下暂停
                    document.getElementById('step-coloring').disabled = false;
                    isAnimating = false;
                    return false;
                }
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed / 2));

                if (isColorSafe(nodeIndex, colorIndex)) {
                    // 可以使用这个颜色
                    nodeColors[nodeIndex] = colorIndex;
                    updateColoringStatus(`节点${nodeIndex}：使用颜色${colorIndex + 1}`);
                    drawGraph();
                    
                    await new Promise(resolve => setTimeout(resolve, animationSpeed / 2));

                    // 递归处理下一个节点
                    if (await solveColoringWithLimit(nodeIndex + 1, maxColors)) {
                        return true;
                    }

                    // 如果递归失败，需要回溯
                    coloringBacktrackCount++;
                    updateColoringStats();
                    updateColoringStatus(`节点${nodeIndex}：颜色${colorIndex + 1}导致无解，回溯尝试下一个颜色`);
                    
                    // 重置当前节点颜色，准备尝试下一个颜色
                    nodeColors[nodeIndex] = -1;
                    selectedNode = nodeIndex;
                    drawGraph();
                    
                    await new Promise(resolve => setTimeout(resolve, animationSpeed / 3));
                } else {
                    // 颜色冲突
                    updateColoringStatus(`节点${nodeIndex}：颜色${colorIndex + 1}与相邻节点冲突`);
                    await new Promise(resolve => setTimeout(resolve, animationSpeed / 4));
                }
            }

            // 所有颜色都试过了，仍然无解
            selectedNode = -1;
            updateColoringStatus(`节点${nodeIndex}：在${maxColors}种颜色限制下无法着色`);
            drawGraph();
            return false;
        }

        // 重置图着色
        function resetColoring() {
            if (coloringAnimationId) clearTimeout(coloringAnimationId);

            isAnimating = false;
            stepMode = false;

            document.getElementById('start-coloring').disabled = (isManualColoringMode === true);
            document.getElementById('step-coloring').disabled = (isManualColoringMode === true);

            nodeColors = Array(graph.nodes.length).fill(-1);
            currentNodeIndex = 0;
            coloringAttemptCount = 0;
            coloringBacktrackCount = 0;
            selectedNode = -1;

            // 重置最优解状态
            bestSolution = null;
            bestColorCount = Infinity;
            currentMaxColors = 1;
            solutionCount = 0;

            // 重新绘制图
            drawGraph();

            updateColoringStats();
            
            if (isManualColoringMode === true) {
                updateColoringStatus('手动模式：选择颜色后点击节点进行着色');
            } else {
                updateColoringStatus('已重置：点击"开始着色"寻找最优方案');
            }
        }

        // 生成新图
        function generateNewGraph() {
            resetColoring();
            generateRandomGraph();
            updateColoringStats();
            updateColoringStatus('已生成新的随机图结构：点击"开始着色"寻找最优方案');
        }

        // 检查颜色是否安全
        function isColorSafe(nodeIndex, colorIndex) {
            const neighbors = graph.adjacencyList[nodeIndex];
            for (let neighbor of neighbors) {
                if (nodeColors[neighbor] === colorIndex) {
                    return false;
                }
            }
            return true;
        }

        // 完成着色动画
        function finishColoringAnimation() {
            isAnimating = false;
            document.getElementById('start-coloring').disabled = false;
            document.getElementById('step-coloring').disabled = false;
            document.getElementById('pause-coloring').disabled = true;
        }

        // 处理节点点击
        function handleNodeClick(nodeIndex) {
            if (!isManualColoringMode || isAnimating) return;
            
            if (nodeColors[nodeIndex] !== -1) {
                // 取消着色
                nodeColors[nodeIndex] = -1;
                drawGraph();
                updateColoringStatus(`取消节点${nodeIndex}的颜色`);
            } else {
                // 尝试着色
                if (isColorSafe(nodeIndex, manualColorIndex)) {
                    nodeColors[nodeIndex] = manualColorIndex;
                    drawGraph();
                    updateColoringStatus(`节点${nodeIndex}使用颜色${manualColorIndex + 1}`);
                    
                    // 检查是否完成
                    const uncolored = nodeColors.filter(color => color === -1);
                    if (uncolored.length === 0) {
                        updateColoringStatus('🎉 恭喜！您已手动完成图着色！');
                    }
                } else {
                    // 显示冲突
                    selectedNode = nodeIndex;
                    drawGraph();
                    setTimeout(() => {
                        selectedNode = -1;
                        drawGraph();
                    }, 500);
                    updateColoringStatus(`节点${nodeIndex}与相邻节点颜色冲突！`);
                }
            }
            updateColoringStats();
        }

        // 处理节点悬停
        function handleNodeHover(nodeIndex) {
            if (isAnimating) return;
            // Canvas版本中悬停效果在drawNode中处理
        }

        // 处理节点离开
        function handleNodeLeave(nodeIndex) {
            if (isAnimating) return;
            // Canvas版本中悬停效果在drawNode中处理
        }

        // 更新图着色状态
        function updateColoringStatus(message) {
            document.getElementById('coloring-status').textContent = message;
        }

        // 更新图着色统计
        function updateColoringStats() {
            const complexity = document.getElementById('graph-complexity')?.value || 'medium';
            const complexityNames = {
                'simple': '简单',
                'medium': '中等', 
                'complex': '复杂'
            };
            
            document.getElementById('current-complexity').textContent = complexityNames[complexity];
            document.getElementById('node-count').textContent = graph.nodes.length;
            document.getElementById('edge-count').textContent = graph.edges.length;
            document.getElementById('coloring-attempt-count').textContent = coloringAttemptCount;
            document.getElementById('coloring-backtrack-count').textContent = coloringBacktrackCount;
            document.getElementById('current-node').textContent = currentNodeIndex;

            const usedColors = new Set(nodeColors.filter(color => color !== -1));
            document.getElementById('colors-used').textContent = usedColors.size;
            
            // 更新最优解信息
            if (bestSolution) {
                document.getElementById('best-color-count').textContent = bestColorCount;
                document.getElementById('solution-count').textContent = solutionCount;
            } else {
                document.getElementById('best-color-count').textContent = '-';
                document.getElementById('solution-count').textContent = '0';
            }
            
            document.getElementById('current-max-colors').textContent = currentMaxColors;
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function () {
            // 默认显示菜单
            showMenu();
        });
    </script>
</body>

</html>